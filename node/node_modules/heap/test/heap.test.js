// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, random;

  Heap = require('..');

  random = Math.random;

  describe('Heap#push, Heap#pop', function() {
    it('should sort an array using push and pop', function() {
      var heap, i, sorted, _i;
      heap = new Heap;
      for (i = _i = 1; _i <= 10; i = ++_i) {
        heap.push(random());
      }
      sorted = ((function() {
        var _results;
        _results = [];
        while (!heap.empty()) {
          _results.push(heap.pop());
        }
        return _results;
      })());
      return sorted.slice().sort().should.eql(sorted);
    });
    return it('should work with custom comparison function', function() {
      var cmp, heap, i, sorted, _i;
      cmp = function(a, b) {
        if (a > b) {
          return -1;
        }
        if (a < b) {
          return 1;
        }
        return 0;
      };
      heap = new Heap(cmp);
      for (i = _i = 1; _i <= 10; i = ++_i) {
        heap.push(random());
      }
      sorted = ((function() {
        var _results;
        _results = [];
        while (!heap.empty()) {
          _results.push(heap.pop());
        }
        return _results;
      })());
      return sorted.slice().sort().reverse().should.eql(sorted);
    });
  });

  describe('Heap#replace', function() {
    return it('should behave like pop() followed by push()', function() {
      var heap, v, _i;
      heap = new Heap;
      for (v = _i = 1; _i <= 5; v = ++_i) {
        heap.push(v);
      }
      heap.replace(3).should.eql(1);
      return heap.toArray().sort().should.eql([2, 3, 3, 4, 5]);
    });
  });

  describe('Heap#pushpop', function() {
    return it('should behave like push() followed by pop()', function() {
      var heap, v, _i;
      heap = new Heap;
      for (v = _i = 1; _i <= 5; v = ++_i) {
        heap.push(v);
      }
      heap.pushpop(6).should.eql(1);
      return heap.toArray().sort().should.eql([2, 3, 4, 5, 6]);
    });
  });

  describe('Heap#contains', function() {
    return it('should return whether it contains the value', function() {
      var heap, v, _i, _j;
      heap = new Heap;
      for (v = _i = 1; _i <= 5; v = ++_i) {
        heap.push(v);
      }
      for (v = _j = 1; _j <= 5; v = ++_j) {
        heap.contains(v).should.be["true"];
      }
      heap.contains(0).should.be["false"];
      return heap.contains(6).should.be["false"];
    });
  });

  describe('Heap#peek', function() {
    return it('should return the top value', function() {
      var heap;
      heap = new Heap;
      heap.push(1);
      heap.peek().should.eql(1);
      heap.push(2);
      heap.peek().should.eql(1);
      heap.pop();
      return heap.peek().should.eql(2);
    });
  });

  describe('Heap#clone', function() {
    return it('should return a cloned heap', function() {
      var a, b, v, _i;
      a = new Heap;
      for (v = _i = 1; _i <= 5; v = ++_i) {
        a.push(v);
      }
      b = a.clone();
      return a.toArray().should.eql(b.toArray());
    });
  });

  describe('Heap.nsmallest', function() {
    it('should return exactly n elements when size() >= n', function() {
      var array;
      Heap.nsmallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3).should.eql([1, 2, 3]);
      array = [1, 3, 2, 1, 3, 4, 4, 2, 3, 4, 5, 1, 2, 3, 4, 5, 2, 1, 3, 4, 5, 6, 7, 2];
      return Heap.nsmallest(array, 2).should.eql([1, 1]);
    });
    return it('should return size() elements when size() <= n', function() {
      return Heap.nsmallest([3, 2, 1], 10).should.eql([1, 2, 3]);
    });
  });

  describe('Heap.nlargest', function() {
    it('should return exactly n elements when size() >= n', function() {
      return Heap.nlargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3).should.eql([10, 9, 8]);
    });
    return it('should return size() elements when size() <= n', function() {
      return Heap.nlargest([3, 2, 1], 10).should.eql([3, 2, 1]);
    });
  });

  describe('Heap#updateItem', function() {
    it('should return correct order', function() {
      var a, b, c, h;
      a = {
        x: 1
      };
      b = {
        x: 2
      };
      c = {
        x: 3
      };
      h = new Heap(function(m, n) {
        return m.x - n.x;
      });
      h.push(a);
      h.push(b);
      h.push(c);
      c.x = 0;
      h.updateItem(c);
      return h.pop().should.eql(c);
    });
    return it('should return correct order when used statically', function() {
      var a, b, c, cmp, h;
      a = {
        x: 1
      };
      b = {
        x: 2
      };
      c = {
        x: 3
      };
      h = [];
      cmp = function(m, n) {
        return m.x - n.x;
      };
      Heap.push(h, a, cmp);
      Heap.push(h, b, cmp);
      Heap.push(h, c, cmp);
      c.x = 0;
      Heap.updateItem(h, c, cmp);
      return Heap.pop(h, cmp).should.eql(c);
    });
  });

}).call(this);
